---
title: 全局对象和模块化开发
---

## Node 程序传递参数

在某些情况下执行`node` 程序的过程中，我们可能希望给 `node`传递一些参数：`node index.js env=development`

如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：

-   获取参数其实是在 `process` 的内置对象中的；
-   `process.argv`（`argument vector`的缩写，传入的具体参数）是一个数组，里面包含了我们需要的参数；

```js
// 终端输入：`node index.js env=development`运行
console.log('hello node')
console.log(process.argv)
process.argv.forEach(item => {
    console.log(item)
})
```

## 特殊的全局对象

这些全局对象可以在模块中任意使用，但是在命令行交互中是不可以使用的

包括：`__dirname`、`__filename`、`exports`、`module`、`require()`

`__dirname`：获取当前文件所在的路径;注意：不包括后面的文件名

`__filename`：获取当前文件所在的路径和文件名称;注意：包括后面的文件名称

```js
console.log(__dirname)
console.log(__filename)
// D:\myProject\gitProject\node_study\特殊的全局对象
// D:\myProject\gitProject\node_study\特殊的全局对象\index.js
```

## 常见的全局对象

### process 对象

`process` 提供了`Node` 进程中相关的信息;比如 `Node` 的运行环境、参数信息等；

### console 对象

提供了简单的调试控制台

### 定时器函数

-   `setTimeout(callback, delay[, ...args])`：callback 在 delay 毫秒后执行一次；
-   `setInterval(callback, delay[, ...args])`：callback 每 delay 毫秒重复执行一次；
-   `setImmediate(callback[, ...args])`：callback I / O 事件后的回调的“立即”执行；
-   `process.nextTick(callback[, ...args])`：添加到下一次 tick 队列中；

## global 对象

`global` 是一个全局对象，事实上 `process`、`console`、`setTimeout` 等都有被放到`global` 中

在浏览器中，全局变量都是在`window` 上的，比如有`document`、`setInterval`、`setTimeout`、`alert`、`console`等等

在 `Node` 中，我们也有一个 `global` 属性，并且看起来它里面有很多其他对象。

但是在浏览器中执行的 `JavaScript` 代码，如果我们在顶级范围内通过 `var` 定义的一个属性，默认会被添加到 `window`对象上

但是在`node`中，我们通过 `var`定义一个变量，它只是在当前模块中有一个变量，不会放到全局中

## 模块化

-   事实上模块化开发最终的目的**是将程序划分成一个个小的结构**；
-   这个结构中编写属于自己的逻辑代码，有自己的**作用域**，不会影响到其他的结构；
-   这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；
-   也可以通过某种方式，导入另外结构中的变量、函数、对象等；

上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程；

JavaScript 本身，直到 ES6（2015）才推出了自己的模块化方案；

为了让 JavaScript 支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS 等；

### 没有模块化带来很多的问题

早期没有模块化带来了很多的问题：比如**命名冲突的问题**

当然，我们有办法可以解决上面的问题：**立即函数调用表达式 `IIFE`**

```js
var module1 = (function() {
    var name = 'frank'

    return {
        name,
    }
})()
```

但是，我们其实带来了新的问题：

-   第一，我必须记得**每一个模块中返回对象的命名**，才能在其他模块使用过程中正确的使用；
-   第二，代码写起来**混乱不堪**，每个文件中的代码都需要**包裹在一个匿名函数中来编写**；
-   第三，在**没有合适的规范**情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；

所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。

-   我们需要制定一定的规范来约束每个人都**按照这个规范去编写模块化的代码**；
-   这个规范中应该包括核心功能：**模块本身可以导出暴露的属性，模块又可以导入自己需要的属性**；
-   JavaScript 社区为了解决上面的问题，涌现出**一系列好用的规范**，接下来我们就学习具有代表性的一些规范。

### CommonJS 和 Node

我们需要知道 **`CommonJS` 是一个规范**，最初提出来是在浏览器以外的地方使用，并且当时被命名为 `ServerJS`，后来为了 体现它的广泛性，修改为`CommonJS`，平时我们也会简称为 `CJS`。

-   `Node` 是`CommonJS` 在服务器端一个具有代表性的实现；
-   `Browserify` 是 `CommonJS` 在浏览器中的一种实现；
-   `webpack`打包工具具备对 `CommonJS` 的支持和转换；

所以，`Node`中对 `CommonJS`进行了支持和实现，让我们在开发 `node` 的过程中可以方便的进行模块化开发：

-   在 Node 中**每一个 `js` 文件都是一个单独的模块**；
-   这个模块中包括 **`CommonJS`规范的核心变量**：`exports`、`module.exports`、`require`；
-   我们可以使用这些变量来方便的进行**模块化开发**；

模块化的核心是导出和导入，`Node`中对其进行了实现：

-   `exports` 和 `module.exports` 可以负责对模块中的内容进行导出
-   `require` 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；
